---
title: "R Notebook"
output: html_notebook
---
# 5 Data transformation: dplyr package

###  Introduction

```{r}
library(nycflights13)
library(tidyverse)

```

Take careful note of the conflicts message that’s printed when you load the tidyverse. It tells you that dplyr overwrites some functions in base R. If you want to use the base version of these functions after loading dplyr, you’ll need to use their full names: stats::filter() and stats::lag().

These describe the type of each variable:

int stands for integers.

dbl stands for doubles, or real numbers.

chr stands for character vectors, or strings.

dttm stands for date-times (a date + a time).

lgl stands for logical, vectors that contain only TRUE or FALSE.

fctr stands for factors, which R uses to represent categorical variables with fixed possible values.

date stands for dates.


#####  data manipulation challenges covered:

Pick observations by their values (filter()).
Reorder the rows (arrange()).
Pick variables by their names (select()).
Create new variables with functions of existing variables (mutate()).
Collapse many values down to a single summary (summarise()).

These can all be used in conjunction with group_by() which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:

1. The first argument is a data frame.

2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).

3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.

```{r}
## Computers use finite precision arithmetic (they obviously can’t store an infinite number of digits!) so remember that every number you see is an approximation. Instead of relying on ==, use near() for floating point numbers

sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2 , 2)

1/49*49 == 1
near(1/49*49, 1)

```

### 5.2 filter()

filter() allows you to subset observations based on their values. The first argument is the name of the data frame. The second and subsequent arguments are the expressions that filter the data frame

```{r}
glimpse(flights)

(jan1 <- filter(flights, month == 1, day == 1))

#A useful short-hand for this problem is x %in% y. This will select every row where x is one of the values in y.
(jan_feb <- filter(flights, month == 1 | month == 2))
#same as
(jan_feb <- filter(flights, month %in% c(1,2)))

```

As well as & and |, R also has && and ||. Don’t use them here! You’ll learn when you should use them in conditional execution.

_Missing values_

 missing values, or NAs (“not availables”). NA represents an unknown value so missing values are “contagious”: almost any operation involving an unknown value will also be unknown.
 
```{r}
NA >5; NA==1; NA/2; 
##The most confusing result is this one:
NA==NA

x<-NA; y <- NA

x==y

#If you want to determine if a value is missing, use is.na():

is.na(x)
```

filter() only includes rows where the condition is TRUE; it excludes both FALSE and NA values. If you want to preserve missing values, ask for them explicitly:

```{r}
df <- tibble(x = c(2,3,1, NA))
filter(df, x>1)
filter(df, x!=1) ##excludes NA

filter(df, x>1 | is.na(x)) ## to include NA into the result
```

### 5.2.4 Exercises




